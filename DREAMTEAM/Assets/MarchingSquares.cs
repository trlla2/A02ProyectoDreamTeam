using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

/* This code was made possible thanks to various recources on the internet that give great explanations of the concept
*  The video Coding marching squares by The codig train (https://www.youtube.com/watch?v=0ZONMNUKTfU&t=1049s&ab_channel=TheCodingTrain) is a fantástic video to
*  understand the functioning of the algorithm. Sebastian Lague also has incredible videos about marching squares and the 3d version of the algorithm marching cubes
*  
*  The main struggle i had was implementing this algorithm to fit into Unitys' mesh creation sistem, as the algorithm uses lines
*  and unity uses triangles. Luckyly videos like Brakeys mesh basics helped understand the concept, Sebastian Lague's videdo and Freedom Coding's marching squares videdo offered exemples on how 
*  to implement the mesh genearation in unity
*/

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class MarchingSquares : MonoBehaviour
{
    [Header("Grid Settings")]
    [SerializeField][Range(5, 500)] private int gridSizeX = 15;
    [SerializeField][Range(5, 500)] private int gridSizeY = 15;
    [SerializeField][Range(0.01f, 0.4f)] private float noiseScale = 0.1f;
    [SerializeField][Range(0.05f, 2f)] private float gridResolution = 1f;
    [SerializeField][Range(0f, 1f)] private float heightThreshold = 0.5f;
    [SerializeField][Range(0f, 30)] private int BorderSize = 1;

    [SerializeField] private int Seed = 0;

    [Header("Debug Settings")]
    [SerializeField] private bool drawGizmos = true;

    private MeshFilter meshFilter;
    private PolygonCollider2D polygonCollider;

    private float[,] heightMap; //float array where we'll store perlin noise values

    //Using lists allows us to have dynamic grid sizes
    private List<Vector3> vertices = new List<Vector3>();
    private List<int> triangles = new List<int>();

    //This dictionary will return a list of triangles cointined for a single point (Thats why we have a V3 key)
    private Dictionary<Vector3, List<Triangle>> vertexToTriangles = new Dictionary<Vector3, List<Triangle>>();

    //This list of int lists till contain all outlines generated by the mesh, as we can have multiple confined outlines in some seeds
    public List<List<int>> outlines = new List<List<int>>();

    //We'll use this hashset to trak wich vertices we have already procesed, using hashsets makes it easier and faster to check contained members inside it
    HashSet<int> processedVertices = new HashSet<int>();

    struct Triangle
    {
        public int v1, v2, v3;

        public Triangle(int V1, int V2, int V3)
        {
            v1 = V1;
            v2 = V2;
            v3 = V3;
        }
    }

    private void Start()
    {
        UpdateGrid();
    }

    
    //public so we can access it thru the editor script
    public void UpdateGrid()
    {
        meshFilter = GetComponent<MeshFilter>();
        polygonCollider = GetComponent<PolygonCollider2D>();
        GenerateHeightMap(Seed);
        MarchSquares();
        CreateMesh();
        UpdatePolygonCollider();
    }

    private void GenerateHeightMap(int seed)
    {
        //we add +1 to each array dimention so the borders are not disconected
        heightMap = new float[gridSizeX + 1, gridSizeY + 1];
        //These values are based on nothing and could be any other
        int seedx = seed % 10 * 13 + 367;
        int seedy = seed * 404 - 21;

        for (int x = 0; x <= gridSizeX; x++)
        {
            for (int y = 0; y <= gridSizeY; y++)
            {
                //These values represent the edges of the board plus the border size and all should be 1 to delimit the playing space
                if (x <= BorderSize || x >= gridSizeX - BorderSize || y <= BorderSize || y >= gridSizeY - BorderSize)
                {
                    heightMap[x, y] = 1;
                }
                else
                {
                    heightMap[x, y] = Mathf.PerlinNoise(x * noiseScale + seedx, y * noiseScale + seedy); //add the seed values to randomize nosie position  
                }
            }
        }
    }

    private void MarchSquares()
    {
        //clear the lists
        vertices.Clear();
        triangles.Clear();

        //Loop through all the squares
        for (int x = 0; x < gridSizeX; x++)
        {
            for (int y = 0; y < gridSizeY; y++)
            {
                //this floats represent the square vertecies and store the values for each one, we count the vertecies of a square 
                //clock-wise (so top left is n1, top rigth is n2, bottom rigth is n3 and bottom left is n4) this is important because
                //when creating meshes in unity triangles need to be inputed clockwise to determine the facin direction
                float a = heightMap[x, y];
                float b = heightMap[x + 1, y];
                float c = heightMap[x + 1, y + 1];
                float d = heightMap[x, y + 1];

                //convert the float falues to 0 or 1 and storing them in these ints
                int aVal = GetBinaryHeight(a);
                int bVal = GetBinaryHeight(b);
                int cVal = GetBinaryHeight(c);
                int dVal = GetBinaryHeight(d);

                //in a square with 4 vertecies that can be active or deactive, there are 16 possible configurations that can be represented in 4 binary bits
                //here by converting the binary values to decimal we can know in what configuration we are
                int configuration = aVal * 8 + bVal * 4 + cVal * 2 + dVal * 1;
                ProcessSquare(configuration, x, y);
            }
        }
    }

    private void ProcessSquare(int configuration, float offsetX, float offsetY)
    {
        Vector3[] localVertices = null; // Store the vertices of the current square
        int[] localTriangles = null; // Store de the index of triangles

        int vertexCount = vertices.Count;

        //The configuration tables have to be hardcoded, luckyly FreedomCoding (https://www.youtube.com/watch?v=LNiTnX7tyVE&ab_channel=FreedomCoding) 
        //provides us with it
        switch (configuration)
        {
            case 0: break;
            case 1:
                localVertices = new Vector3[] { new Vector3(0, 1f), new Vector3(0, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 2, 1, 0 };
                break;
            case 2:
                localVertices = new Vector3[] { new Vector3(1, 1), new Vector3(1, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 0, 1, 2 };
                break;
            case 3:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
            case 4:
                localVertices = new Vector3[] { new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2 };
                break;
            case 5:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 1), new Vector3(0.5f, 1), new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 3, 4, 5 };
                break;
            case 6:
                localVertices = new Vector3[] { new Vector3(0.5f, 0), new Vector3(0.5f, 1), new Vector3(1, 1), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
            case 7:
                localVertices = new Vector3[] { new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(0, 0.5f) };
                localTriangles = new int[] { 2, 3, 1, 3, 4, 1, 4, 0, 1 };
                break;
            case 8:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 0), new Vector3(0.5f, 0) };
                localTriangles = new int[] { 2, 1, 0 };
                break;
            case 9:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0.5f, 0), new Vector3(0.5f, 1), new Vector3(0, 1) };
                localTriangles = new int[] { 1, 0, 2, 0, 3, 2 };
                break;
            case 10:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 0.5f), new Vector3(0.5f, 0), new Vector3(1, 1), new Vector3(0.5f, 1), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 5, 4, 3 };
                break;
            case 11:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0.5f), new Vector3(0.5f, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3, 4, 0, 3 };
                break;
            case 12:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(1, 0), new Vector3(1, 0.5f), new Vector3(0, 0.5f) };
                localTriangles = new int[] { 0, 3, 2, 0, 2, 1 };
                break;
            case 13:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(0.5f, 1), new Vector3(1, 0.5f), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3, 0, 3, 4 };
                break;
            case 14:
                localVertices = new Vector3[] { new Vector3(1, 1), new Vector3(1, 0), new Vector3(0, 0), new Vector3(0, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 0, 1, 4, 1, 3, 4, 1, 2, 3 };
                break;
            case 15:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
        }

        if (localVertices != null)
        {
            // Add the local vertices to the global vertices list, adjusting for grid position(offsetY and offsetX) and resolution
            foreach (Vector3 vert in localVertices)
            {
                Vector3 newVert = new Vector3((vert.x + offsetX) * gridResolution, (vert.y + offsetY) * gridResolution, 0);
                //Round up to 3 decimal places to avoid precision errors
                newVert.x = Mathf.Round(newVert.x * 1000) / 1000;
                newVert.y = Mathf.Round(newVert.y * 1000) / 1000;
                vertices.Add(newVert);
            }
            // Add the local triangles to the global triangles list, adjusting for vertex count
            foreach (int triangle in localTriangles)
            {
                triangles.Add(triangle + vertexCount);
            }
            // Store the triangles in the dictionary
            for (int i = 0; i < localTriangles.Length; i += 3)
            {
                Triangle tri = new Triangle(localTriangles[i] + vertexCount, localTriangles[i + 1] + vertexCount, localTriangles[i + 2] + vertexCount);
                AddTriangleToVertex(vertices[tri.v1], tri);
                AddTriangleToVertex(vertices[tri.v2], tri);
                AddTriangleToVertex(vertices[tri.v3], tri);
            }

        }
    }
    //This function adds triangles to the dictionry
    private void AddTriangleToVertex(Vector3 vertex, Triangle triangle)
    {
        //If its the first time we encounter this key
        if (!vertexToTriangles.ContainsKey(vertex))
        {
            //create a new list for the key
            vertexToTriangles[vertex] = new List<Triangle>();
        }
        //add the triangle to the assaciated key list
        vertexToTriangles[vertex].Add(triangle);
    }

    private void UpdatePolygonCollider()
    {
        outlines.Clear();
        processedVertices.Clear();
        polygonCollider.points = null;

        //We'll use this to define the ammount of paths there are in the map 
        polygonCollider.pathCount = 0;

        //Find all potential outlines in the mesh by going thru all vertices that have not already been procesed
        for (int i = 0; i < vertices.Count; i++)
        {
            if (!processedVertices.Contains(i))
            {
                //cerate a new outline
                List<int> newOutline = new List<int>();

                FindOutline(i, newOutline);

                if (newOutline.Count > 0)
                {
                    outlines.Add(newOutline);
                }
            }
        }

        //Filter out unwanted colliders
        List<List<int>> validOutlines = new List<List<int>>();
        foreach (var outline in outlines)
        {
            bool isValidOutline = true;

            // Check if outline is part of map border
            foreach (int vertexIndex in outline)
            {
                Vector3 vertex = vertices[vertexIndex];

                // Calculate original grid position
                float originalX = vertex.x / gridResolution;
                float originalY = vertex.y / gridResolution;

                // Check if vertex is within border area
                if (originalX < BorderSize || originalX > gridSizeX - BorderSize ||
                    originalY < BorderSize || originalY > gridSizeY - BorderSize)
                {
                    isValidOutline = false;
                    break;
                }
            }
            if (isValidOutline)
            {
                validOutlines.Add(outline);
            }
        }
        //Set the path number to the outlines ammount
        polygonCollider.pathCount = validOutlines.Count;

        //Apply filtered outlines to polygon collider
        for (int i = 0; i < validOutlines.Count; i++)
        {
            List<Vector2> path = new List<Vector2>();
            foreach (int j in validOutlines[i]) 
            {
                path.Add(new Vector2(vertices[j].x, vertices[j].y));
            }

            // Ensure closed loop
            if (path.Count > 0 && path[0] != path[path.Count - 1])
            {
                path.Add(path[0]);
            }

            polygonCollider.SetPath(i, path.ToArray());
        }
    }
    //Trace a single outline starting form a givn vertex
    private void FindOutline(int startVertex, List<int> outline)
    {
        int currentVertex = startVertex;

        outline.Add(currentVertex);
        processedVertices.Add(currentVertex);

        while (true)
        {
            int nextVertex = -1; 
            List<Triangle> triangles = vertexToTriangles[vertices[currentVertex]];

            // Check all triangles containing the current vertex
            foreach (Triangle tri in triangles)
            {
                int[] edges = { tri.v1, tri.v2, tri.v3 };

                // Check each edge connection
                for (int i = 0; i < 3; i++)
                {
                    // Get adjacent vertex round up to not exeed i
                    int adj = edges[(i + 1) % 3];

                    //If we find an adjecent vertex that forms a unique edge for unly one triangle (so it defines the outline) and has not been processed yet
                    if (edges[i] == currentVertex && IsEdgeUnique(edges[i], adj) && !processedVertices.Contains(adj))
                    {
                        nextVertex = adj; // Found valid next vertex
                        break;
                    }
                }
                if (nextVertex != -1) break; // Exit early if path found
            }

            // if No next vertex found (dead end) or the Next vertex is the start vertex (loop completed)
            if (nextVertex == -1 || nextVertex == startVertex) break;

            // Add next vertex to outline and mark as processed
            outline.Add(nextVertex);
            processedVertices.Add(nextVertex);

            currentVertex = nextVertex; // Move to next vertex
        }
    }

    //This function checks if a specific edge is only contained in one triangle
    //Edges that only sare 1 triangle define the outline of the mesh, if they share more than 1 triangle it means they are contained inside the mesh
    private bool IsEdgeUnique(int v1, int v2)
    {
        int count = 0;
        List<Triangle> trianglesContainingV1 = vertexToTriangles[vertices[v1]];
        List<Triangle> trianglesContainingV2 = vertexToTriangles[vertices[v2]];

        //Iterate thru the triangles in the dictionary associated to the V1 key
        foreach (Triangle triangle in trianglesContainingV1)
        {
            //check if the given vertices form an edge in any triangle
            if ((triangle.v1 == v1 && triangle.v2 == v2) ||
                (triangle.v2 == v1 && triangle.v3 == v2) ||
                (triangle.v3 == v1 && triangle.v1 == v2))
            {
                count++;
            }
        }
        //same for the V2 key
        foreach (Triangle triangle in trianglesContainingV2)
        {
            if ((triangle.v1 == v2 && triangle.v2 == v1) ||
                (triangle.v2 == v2 && triangle.v3 == v1) ||
                (triangle.v3 == v2 && triangle.v1 == v1))
            {
                count++;
            }
        }
        //if only 1 triangle contains the edge return true
        return count == 1;
    }

    private void CreateMesh()
    {
        //passin the vertices and triangles array
        Mesh mesh = new Mesh();
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();

        mesh.RecalculateNormals(); // Adjust ligthing

        meshFilter.mesh = mesh;

    }

    private int GetBinaryHeight(float value)
    {
        return value < heightThreshold ? 0 : 1;
    }

    private void OnDrawGizmos()
    {
        if (!drawGizmos || heightMap == null) return;

        for (int x = 0; x <= gridSizeX; x++)
        {
            for (int y = 0; y <= gridSizeY; y++)
            {
                //draw spheres to represent the square grid vertices and ajust the color to visualize the heigthmap
                Vector3 pos = transform.TransformPoint(new Vector3(x * gridResolution, y * gridResolution, 0));
                Gizmos.color = new Color(heightMap[x, y], heightMap[x, y], heightMap[x, y], 1);
                Gizmos.DrawSphere(pos, gridResolution * 0.1f);
            }
        }
    }
}