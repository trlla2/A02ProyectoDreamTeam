using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine;

/* This code was made possible thanks to various recources on the internet that give great explanations of the concept
*  The video Coding marching squares by The codig train (https://www.youtube.com/watch?v=0ZONMNUKTfU&t=1049s&ab_channel=TheCodingTrain) is a fantástic video to
*  understand the functioning of the algorithm. Sebastian Lague also has incredible videos about marching squares and the 3d version of the algorithm marching cubes
*  
*  The main struggle i had was implementing this algorithm to fit into Unitys' mesh creation sistem, as the algorithm uses lines
*  and unity uses triangles. Luckyly videos like Brakeys mesh basics helped understand the concept, Sebastian Lague's videdo and Freedom Coding's marching squares videdo offered exemples on how 
*  to implement the mesh genearation in unity
*/

[RequireComponent(typeof(MeshFilter), typeof(MeshRenderer))]
public class MarchingSquares : MonoBehaviour
{
    [Header("Grid Settings")]
    [SerializeField][Range(5, 500)] private int gridSizeX = 15;
    [SerializeField][Range(5, 500)] private int gridSizeY = 15;
    [SerializeField][Range(0.01f, 0.4f)] private float noiseScale = 0.1f;
    [SerializeField][Range(0.05f, 2f)] private float gridResolution = 1f;
    [SerializeField][Range(0f, 1f)] private float heightThreshold = 0.5f;
    [SerializeField][Range(0f, 15)] private int BorderSize = 1;

    [SerializeField] private int Seed = 0;

    [Header("Debug Settings")]
    [SerializeField] private bool drawGizmos = true;

    private MeshFilter meshFilter;
    private EdgeCollider2D edgeCollider;

    private float[,] heightMap; //float array where we'll store perlin noise values

    //Using lists allows us to have dynamic grid sizes
    private List<Vector3> vertices = new List<Vector3>();
    private List<int> triangles = new List<int>();

    //This dictionary will return a list of triangles cointined for a single point (Thats why we have a V3 key)
    private Dictionary<Vector3, List<Triangle>> vertexToTriangles = new Dictionary<Vector3, List<Triangle>>();

    //This list of int lists till contain all outlines generated by the mesh, as we can have multiple confined outlines in some seeds
    public List<List<int>> outlines = new List<List<int>>();

    //We'll use this hashset to trak wich vertices we have already procesed, using hashsets makes it easier and faster to check contained members inside it
    HashSet<int> processedVertices = new HashSet<int>();

    struct Triangle
    {
        public int v1, v2, v3;

        public Triangle(int V1, int V2, int V3)
        {
            v1 = V1;
            v2 = V2;
            v3 = V3;
        }
    }

    private void Start()
    {
        UpdateGrid();
    }

    
    //public so we can access it thru the editor script
    public void UpdateGrid()
    {
        meshFilter = GetComponent<MeshFilter>();
        edgeCollider = GetComponent<EdgeCollider2D>();
        GenerateHeightMap(Seed);
        MarchSquares();
        CreateMesh();
        UpdateEdgeCollider();
    }

    private void GenerateHeightMap(int seed)
    {
        //we add +1 to each array dimention so the borders are not disconected
        heightMap = new float[gridSizeX + 1, gridSizeY + 1];
        //These values are based on nothing and could be any other
        int seedx = seed % 10 * 13 + 367;
        int seedy = seed * 404 - 21;

        for (int x = 0; x <= gridSizeX; x++)
        {
            for (int y = 0; y <= gridSizeY; y++)
            {
                //These values represent the edges of the board plus the border size and all should be 1 to delimit the playing space
                if (x <= BorderSize || x >= gridSizeX - BorderSize || y <= BorderSize || y >= gridSizeY - BorderSize)
                {
                    heightMap[x, y] = 1;
                }
                else
                {
                    heightMap[x, y] = Mathf.PerlinNoise(x * noiseScale + seedx, y * noiseScale + seedy); //add the seed values to randomize nosie position  
                }
            }
        }
    }

    private void MarchSquares()
    {
        //clear the lists
        vertices.Clear();
        triangles.Clear();

        //Loop through all the squares
        for (int x = 0; x < gridSizeX; x++)
        {
            for (int y = 0; y < gridSizeY; y++)
            {
                //this floats represent the square vertecies and store the values for each one, we count the vertecies of a square 
                //clock-wise (so top left is n1, top rigth is n2, bottom rigth is n3 and bottom left is n4) this is important because
                //when creating meshes in unity triangles need to be inputed clockwise to determine the facin firection
                float a = heightMap[x, y];
                float b = heightMap[x + 1, y];
                float c = heightMap[x + 1, y + 1];
                float d = heightMap[x, y + 1];

                //convert the float falues to 0 or 1 and storing them in these ints
                int aVal = GetBinaryHeight(a);
                int bVal = GetBinaryHeight(b);
                int cVal = GetBinaryHeight(c);
                int dVal = GetBinaryHeight(d);

                //in a square with 4 vertecies that can be active or deactive, there are 16 possible configurations that can be represented in 4 binary bits
                //here by converting the binary values to decimal we can know in what configuration we are
                int configuration = aVal * 8 + bVal * 4 + cVal * 2 + dVal * 1;
                ProcessSquare(configuration, x, y);
            }
        }
    }

    private void ProcessSquare(int configuration, float offsetX, float offsetY)
    {
        Vector3[] localVertices = null; // Store the vertices of the current square
        int[] localTriangles = null; // Store de the index of triangles

        int vertexCount = vertices.Count;

        //The configuration tables have to be hardcoded, luckyly FreedomCoding (https://www.youtube.com/watch?v=LNiTnX7tyVE&ab_channel=FreedomCoding) 
        //provides us with it
        switch (configuration)
        {
            case 0:
                return;
            case 1:
                localVertices = new Vector3[] { new Vector3(0, 1f), new Vector3(0, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 2, 1, 0 };
                break;
            case 2:
                localVertices = new Vector3[] { new Vector3(1, 1), new Vector3(1, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 0, 1, 2 };
                break;
            case 3:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
            case 4:
                localVertices = new Vector3[] { new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2 };
                break;
            case 5:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 1), new Vector3(0.5f, 1), new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 3, 4, 5 };
                break;
            case 6:
                localVertices = new Vector3[] { new Vector3(0.5f, 0), new Vector3(0.5f, 1), new Vector3(1, 1), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
            case 7:
                localVertices = new Vector3[] { new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0), new Vector3(0.5f, 0), new Vector3(0, 0.5f) };
                localTriangles = new int[] { 2, 3, 1, 3, 4, 1, 4, 0, 1 };
                break;
            case 8:
                localVertices = new Vector3[] { new Vector3(0, 0.5f), new Vector3(0, 0), new Vector3(0.5f, 0) };
                localTriangles = new int[] { 2, 1, 0 };
                break;
            case 9:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0.5f, 0), new Vector3(0.5f, 1), new Vector3(0, 1) };
                localTriangles = new int[] { 1, 0, 2, 0, 3, 2 };
                break;
            case 10:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 0.5f), new Vector3(0.5f, 0), new Vector3(1, 1), new Vector3(0.5f, 1), new Vector3(1, 0.5f) };
                localTriangles = new int[] { 0, 1, 2, 5, 4, 3 };
                break;
            case 11:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0.5f), new Vector3(0.5f, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3, 4, 0, 3 };
                break;
            case 12:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(1, 0), new Vector3(1, 0.5f), new Vector3(0, 0.5f) };
                localTriangles = new int[] { 0, 3, 2, 0, 2, 1 };
                break;
            case 13:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(0.5f, 1), new Vector3(1, 0.5f), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3, 0, 3, 4 };
                break;
            case 14:
                localVertices = new Vector3[] { new Vector3(1, 1), new Vector3(1, 0), new Vector3(0, 0), new Vector3(0, 0.5f), new Vector3(0.5f, 1) };
                localTriangles = new int[] { 0, 1, 4, 1, 3, 4, 1, 2, 3 };
                break;
            case 15:
                localVertices = new Vector3[] { new Vector3(0, 0), new Vector3(0, 1), new Vector3(1, 1), new Vector3(1, 0) };
                localTriangles = new int[] { 0, 1, 2, 0, 2, 3 };
                break;
        }

        if (localVertices != null)
        {
            // Add the local vertices to the global vertices list, adjusting for grid position(offsetY and offsetX) and resolution
            foreach (Vector3 vert in localVertices)
            {
                Vector3 newVert = new Vector3((vert.x + offsetX) * gridResolution, (vert.y + offsetY) * gridResolution, 0);
                vertices.Add(newVert);
            }
            // Add the local triangles to the global triangles list, adjusting for vertex count
            foreach (int triangle in localTriangles)
            {
                triangles.Add(triangle + vertexCount);
            }
            // Store the triangles in the dictionary
            for (int i = 0; i < localTriangles.Length; i += 3)
            {
                Triangle tri = new Triangle(localTriangles[i] + vertexCount, localTriangles[i + 1] + vertexCount, localTriangles[i + 2] + vertexCount);
                AddTriangleToVertex(vertices[tri.v1], tri);
                AddTriangleToVertex(vertices[tri.v2], tri);
                AddTriangleToVertex(vertices[tri.v3], tri);
            }

        }
    }
    //This function adds triangles to the dictionry
    private void AddTriangleToVertex(Vector3 vertex, Triangle triangle)
    {
        //If its the first time we encounter this key
        if (!vertexToTriangles.ContainsKey(vertex))
        {
            //create a new list for the key
            vertexToTriangles[vertex] = new List<Triangle>();
        }
        //add the triangle to the assaciated key list
        vertexToTriangles[vertex].Add(triangle);
    }

    private void UpdateEdgeCollider()
    {
        outlines.Clear();
        processedVertices.Clear();
        edgeCollider.points = new Vector2[0];

        // Iterate through all vertices
        for (int i = 0; i < vertices.Count; i++)
        {
            // Skip if the vertex has already been processed, continue means move to the next i value without executing the remaining code
            if (processedVertices.Contains(i)) continue;

            // Start a new outline
            List<int> newOutline = new List<int>();
            FindOutline(i, processedVertices, newOutline);

            // Add the new outline to the list of outlines
            if (newOutline.Count > 0)
            {
                outlines.Add(newOutline);
            }
        }

        List<Vector2> edges = new List<Vector2>();

        foreach (var outline in outlines)
        {
            for (int i = 0; i < outline.Count; i++)
            {
                int vertexIndex = outline[i];
                edges.Add(new Vector2(vertices[vertexIndex].x, vertices[vertexIndex].y));
            }
            edgeCollider.points = edges.ToArray();
        }
    }
    //Trace a single outline starting form a givn vertex
    private void FindOutline(int startVertex, HashSet<int> processedVertices, List<int> outline)
    {
        int currentVertex = startVertex;
        int nextVertex = -1; // assing -1 for the moment so we can detect errors

        do
        {
            outline.Add(currentVertex); // Add the current vertex to the outline
            processedVertices.Add(currentVertex); //Add the current vertex to the hashset so we dont iterate thru it again

            // Find the next vertex in the outline
            nextVertex = FindNextOutlineVertex(currentVertex, processedVertices);
            currentVertex = nextVertex;

        } while (currentVertex != startVertex && currentVertex != -1); // do until the next vertex is the start vertex (complete circuit) or there's no next vertex

        // Close the loop
        if (currentVertex == startVertex)
        {
            outline.Add(startVertex);
        }
    }

    private int FindNextOutlineVertex(int currentVertex, HashSet<int> processedVertices)
    {
        // Get all triangles from the dictionary that include the current vertex
        List<Triangle> connectedTriangles = vertexToTriangles[vertices[currentVertex]];

        // Iterate through the edges of the connected triangles
        foreach (Triangle triangle in connectedTriangles)
        {
            // Get triangle edges and store them in an array
            int[] edgeVertices = new int[] { triangle.v1, triangle.v2, triangle.v3 };

            for (int i = 0; i < 3; i++)
            {
                int v1 = edgeVertices[i];
                int v2 = edgeVertices[(i + 1) % 3]; // round up the index (so if i+1 = 3 it'll be converted to 0)

                // Check if the Edge(form v1 to v2) is part of the outline and has not been procesed
                if (v1 == currentVertex && IsEdgeUnique(v1, v2) && !processedVertices.Contains(v2))
                {
                    return v2;
                }
                if (v2 == currentVertex && IsEdgeUnique(v2, v1) && !processedVertices.Contains(v1))
                {
                    return v1;
                }
            }
        }
        // No next vertex found
        return -1;
    }

    //This function checks if a specific edge is only contained in one triangle
    //Edges that only sare 1 triangle define the outline of the mesh, if they share more than 1 triangle it means they are contained inside the mesh
    private bool IsEdgeUnique(int v1, int v2)
    {
        int count = 0;
        List<Triangle> trianglesContainingV1 = vertexToTriangles[vertices[v1]];

        //Iterate thru the triangles in the dictionary
        foreach (Triangle triangle in trianglesContainingV1)
        {
            //check if the given vertices form an edge in any triangle
            if ((triangle.v1 == v1 && triangle.v2 == v2) ||
                (triangle.v2 == v1 && triangle.v3 == v2) ||
                (triangle.v3 == v1 && triangle.v1 == v2))
            {
                count++;
            }
        }
        //if only 1 triangle contains the edge return true
        return count == 1;
    }

    private void CreateMesh()
    {
        //passin the vertices and triangles array
        Mesh mesh = new Mesh();
        mesh.vertices = vertices.ToArray();
        mesh.triangles = triangles.ToArray();

        mesh.RecalculateNormals(); // Adjust ligthing

        meshFilter.mesh = mesh;

    }

    private int GetBinaryHeight(float value)
    {
        return value < heightThreshold ? 0 : 1;
    }

    private void OnDrawGizmos()
    {
        if (!drawGizmos || heightMap == null) return;

        for (int x = 0; x <= gridSizeX; x++)
        {
            for (int y = 0; y <= gridSizeY; y++)
            {
                //draw spheres to represent the square grid vertices and ajust the color to visualize the heigthmap
                Vector3 pos = transform.TransformPoint(new Vector3(x * gridResolution, y * gridResolution, 0));
                Gizmos.color = new Color(heightMap[x, y], heightMap[x, y], heightMap[x, y], 1);
                Gizmos.DrawSphere(pos, gridResolution * 0.1f);
            }
        }
    }
}